// Copyright 2017 Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package bootstrapTemplateTest

import (
	"context"
	"errors"
	"fmt"

	"github.com/gogo/protobuf/proto"
	"github.com/golang/glog"

	"istio.io/api/mixer/v1/config/descriptor"
	adptTmpl "istio.io/api/mixer/v1/template"
	"istio.io/istio/mixer/pkg/adapter"
	"istio.io/istio/mixer/pkg/attribute"
	"istio.io/istio/mixer/pkg/expr"
	"istio.io/istio/mixer/pkg/template"

	"istio.io/istio/mixer/template/list"

	"istio.io/istio/mixer/template/quota"

	"istio.io/istio/mixer/template/log"

	"istio.io/istio/mixer/template/metric"

	"time"
)

const emptyQuotes = "\"\""

var (
	SupportedTmplInfo = map[string]template.Info{

		istio_mixer_template_list.TemplateName: {
			Name:               istio_mixer_template_list.TemplateName,
			Impl:               "istio.mixer.template.list",
			CtrCfg:             &istio_mixer_template_list.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  istio_mixer_template_list.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: istio_mixer_template_list.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_list.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_list.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(cpb *istio_mixer_template_list.InstanceParam) (*istio_mixer_template_list.Type, error)
				_ = BuildTemplate

				var BuildRes1 func(cpb *istio_mixer_template_list.Res1InstanceParam) (*istio_mixer_template_list.Res1Type, error)
				_ = BuildRes1

				var BuildRes2 func(cpb *istio_mixer_template_list.Res2InstanceParam) (*istio_mixer_template_list.Res2Type, error)
				_ = BuildRes2

				BuildTemplate = func(cpb *istio_mixer_template_list.InstanceParam) (*istio_mixer_template_list.Type, error) {
					infrdType := &istio_mixer_template_list.Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if cpb.AnotherValueType == "" || cpb.AnotherValueType == emptyQuotes {
						return nil, errors.New("expression for field AnotherValueType cannot be empty")
					}
					if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
						return nil, err
					}

					for _, v := range cpb.DimensionsFixedInt64ValueDType {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					if cpb.CheckExpression == "" || cpb.CheckExpression == emptyQuotes {
						return nil, errors.New("expression for field CheckExpression cannot be empty")
					}
					if t, e := tEvalFn(cpb.CheckExpression); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field CheckExpression: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field CheckExpression: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if cpb.Res1 != nil {
						if infrdType.Res1, err = BuildRes1(cpb.Res1); err != nil {
							return nil, err
						}
					}

					return infrdType, err
				}

				BuildRes1 = func(cpb *istio_mixer_template_list.Res1InstanceParam) (*istio_mixer_template_list.Res1Type, error) {
					infrdType := &istio_mixer_template_list.Res1Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					for _, v := range cpb.Int64Map {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field Int64Map: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field Int64Map: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					if cpb.TimeStamp == "" || cpb.TimeStamp == emptyQuotes {
						return nil, errors.New("expression for field TimeStamp cannot be empty")
					}
					if t, e := tEvalFn(cpb.TimeStamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field TimeStamp: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field TimeStamp: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if cpb.Duration == "" || cpb.Duration == emptyQuotes {
						return nil, errors.New("expression for field Duration cannot be empty")
					}
					if t, e := tEvalFn(cpb.Duration); e != nil || t != istio_mixer_v1_config_descriptor.DURATION {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Duration: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Duration: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DURATION)
					}

					if cpb.Res2 != nil {
						if infrdType.Res2, err = BuildRes2(cpb.Res2); err != nil {
							return nil, err
						}
					}

					infrdType.Res2Map = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Res2Map))
					for k, v := range cpb.Res2Map {

						if infrdType.Res2Map[k], err = BuildRes2(v); err != nil {
							return nil, err
						}

					}

					return infrdType, err
				}

				BuildRes2 = func(cpb *istio_mixer_template_list.Res2InstanceParam) (*istio_mixer_template_list.Res2Type, error) {
					infrdType := &istio_mixer_template_list.Res2Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					return infrdType, err
				}

				return BuildTemplate(cp.(*istio_mixer_template_list.InstanceParam))
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(istio_mixer_template_list.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_list.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_list.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetListTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler) (adapter.CheckResult, error) {

				var BuildTemplate func(instName string, md *istio_mixer_template_list.InstanceParam) (*istio_mixer_template_list.Instance, error)
				_ = BuildTemplate

				var BuildRes1 func(instName string, md *istio_mixer_template_list.Res1InstanceParam) (*istio_mixer_template_list.Res1, error)
				_ = BuildRes1

				var BuildRes2 func(instName string, md *istio_mixer_template_list.Res2InstanceParam) (*istio_mixer_template_list.Res2, error)
				_ = BuildRes2

				BuildTemplate = func(instName string, md *istio_mixer_template_list.InstanceParam) (*istio_mixer_template_list.Instance, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					AnotherValueType, err := mapper.Eval(md.AnotherValueType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DimensionsFixedInt64ValueDType, err := template.EvalAll(md.DimensionsFixedInt64ValueDType, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					CheckExpression, err := mapper.Eval(md.CheckExpression, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval CheckExpression for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res1, err := BuildRes1(instName, md.Res1)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res1 for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					_ = md
					return &istio_mixer_template_list.Instance{

						Name: instName,

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						AnotherValueType: AnotherValueType,

						DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(DimensionsFixedInt64ValueDType),

						CheckExpression: CheckExpression.(string),

						Res1: Res1,
					}, nil
				}

				BuildRes1 = func(instName string, md *istio_mixer_template_list.Res1InstanceParam) (*istio_mixer_template_list.Res1, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Map, err := template.EvalAll(md.Int64Map, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Map for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					TimeStamp, err := mapper.Eval(md.TimeStamp, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval TimeStamp for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Duration, err := mapper.Eval(md.Duration, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Duration for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res2, err := BuildRes2(instName, md.Res2)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res2 for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res2Map = make(map[string]*Res2, len(md.Res2Map))
					for k, v := range md.Res2Map {
						if Res2Map[k], err = BuildRes2(v); err != nil {
							return nil, err
						}
					}

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res2Map for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					_ = md
					return &istio_mixer_template_list.Res1{

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						Int64Map: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(Int64Map),

						TimeStamp: TimeStamp.(time.Time),

						Duration: Duration.(time.Duration),

						Res2: Res2,

						Res2Map: Res2Map,
					}, nil
				}

				BuildRes2 = func(instName string, md *istio_mixer_template_list.Res2InstanceParam) (*istio_mixer_template_list.Res2, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					_ = md
					return &istio_mixer_template_list.Res2{

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),
					}, nil
				}

				instance, err := BuildTemplate(instName, inst.(*istio_mixer_template_list.InstanceParam))
				if err != nil {

					return adapter.CheckResult{}, err

				}
				return handler.(istio_mixer_template_list.Handler).HandleList(ctx, instance)

			},
		},

		istio_mixer_template_quota.TemplateName: {
			Name:               istio_mixer_template_quota.TemplateName,
			Impl:               "istio.mixer.template.quota",
			CtrCfg:             &istio_mixer_template_quota.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_QUOTA,
			BldrInterfaceName:  istio_mixer_template_quota.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: istio_mixer_template_quota.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_quota.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_quota.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(cpb *istio_mixer_template_quota.InstanceParam) (*istio_mixer_template_quota.Type, error)
				_ = BuildTemplate

				BuildTemplate = func(cpb *istio_mixer_template_quota.InstanceParam) (*istio_mixer_template_quota.Type, error) {
					infrdType := &istio_mixer_template_quota.Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if cpb.AnotherValueType == "" || cpb.AnotherValueType == emptyQuotes {
						return nil, errors.New("expression for field AnotherValueType cannot be empty")
					}
					if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
						return nil, err
					}

					for _, v := range cpb.DimensionsFixedInt64ValueDType {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					return infrdType, err
				}

				return BuildTemplate(cp.(*istio_mixer_template_quota.InstanceParam))
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(istio_mixer_template_quota.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_quota.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_quota.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetQuotaTypes(castedTypes)
			},

			ProcessQuota: func(ctx context.Context, instName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler, args adapter.QuotaArgs) (adapter.QuotaResult, error) {

				var BuildTemplate func(instName string, md *istio_mixer_template_quota.InstanceParam) (*istio_mixer_template_quota.Instance, error)
				_ = BuildTemplate

				BuildTemplate = func(instName string, md *istio_mixer_template_quota.InstanceParam) (*istio_mixer_template_quota.Instance, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					AnotherValueType, err := mapper.Eval(md.AnotherValueType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DimensionsFixedInt64ValueDType, err := template.EvalAll(md.DimensionsFixedInt64ValueDType, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					_ = md
					return &istio_mixer_template_quota.Instance{

						Name: instName,

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						AnotherValueType: AnotherValueType,

						DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(DimensionsFixedInt64ValueDType),
					}, nil
				}

				instance, err := BuildTemplate(instName, inst.(*istio_mixer_template_quota.InstanceParam))
				if err != nil {
					return adapter.QuotaResult{}, err

				}
				return handler.(istio_mixer_template_quota.Handler).HandleQuota(ctx, instance, args)

			},
		},

		istio_mixer_template_log.TemplateName: {
			Name:               istio_mixer_template_log.TemplateName,
			Impl:               "istio.mixer.template.log",
			CtrCfg:             &istio_mixer_template_log.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  istio_mixer_template_log.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: istio_mixer_template_log.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_log.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_log.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(cpb *istio_mixer_template_log.InstanceParam) (*istio_mixer_template_log.Type, error)
				_ = BuildTemplate

				var BuildRes1 func(cpb *istio_mixer_template_log.Res1InstanceParam) (*istio_mixer_template_log.Res1Type, error)
				_ = BuildRes1

				var BuildRes2 func(cpb *istio_mixer_template_log.Res2InstanceParam) (*istio_mixer_template_log.Res2Type, error)
				_ = BuildRes2

				BuildTemplate = func(cpb *istio_mixer_template_log.InstanceParam) (*istio_mixer_template_log.Type, error) {
					infrdType := &istio_mixer_template_log.Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if cpb.AnotherValueType == "" || cpb.AnotherValueType == emptyQuotes {
						return nil, errors.New("expression for field AnotherValueType cannot be empty")
					}
					if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
						return nil, err
					}

					for _, v := range cpb.DimensionsFixedInt64ValueDType {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					if cpb.TimeStamp == "" || cpb.TimeStamp == emptyQuotes {
						return nil, errors.New("expression for field TimeStamp cannot be empty")
					}
					if t, e := tEvalFn(cpb.TimeStamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field TimeStamp: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field TimeStamp: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if cpb.Duration == "" || cpb.Duration == emptyQuotes {
						return nil, errors.New("expression for field Duration cannot be empty")
					}
					if t, e := tEvalFn(cpb.Duration); e != nil || t != istio_mixer_v1_config_descriptor.DURATION {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Duration: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Duration: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DURATION)
					}

					if cpb.Res1 != nil {
						if infrdType.Res1, err = BuildRes1(cpb.Res1); err != nil {
							return nil, err
						}
					}

					return infrdType, err
				}

				BuildRes1 = func(cpb *istio_mixer_template_log.Res1InstanceParam) (*istio_mixer_template_log.Res1Type, error) {
					infrdType := &istio_mixer_template_log.Res1Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					for _, v := range cpb.Int64Map {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field Int64Map: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field Int64Map: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					if cpb.TimeStamp == "" || cpb.TimeStamp == emptyQuotes {
						return nil, errors.New("expression for field TimeStamp cannot be empty")
					}
					if t, e := tEvalFn(cpb.TimeStamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field TimeStamp: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field TimeStamp: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
					}

					if cpb.Duration == "" || cpb.Duration == emptyQuotes {
						return nil, errors.New("expression for field Duration cannot be empty")
					}
					if t, e := tEvalFn(cpb.Duration); e != nil || t != istio_mixer_v1_config_descriptor.DURATION {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Duration: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Duration: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DURATION)
					}

					if cpb.Res2 != nil {
						if infrdType.Res2, err = BuildRes2(cpb.Res2); err != nil {
							return nil, err
						}
					}

					infrdType.Res2Map = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Res2Map))
					for k, v := range cpb.Res2Map {

						if infrdType.Res2Map[k], err = BuildRes2(v); err != nil {
							return nil, err
						}

					}

					return infrdType, err
				}

				BuildRes2 = func(cpb *istio_mixer_template_log.Res2InstanceParam) (*istio_mixer_template_log.Res2Type, error) {
					infrdType := &istio_mixer_template_log.Res2Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					return infrdType, err
				}

				return BuildTemplate(cp.(*istio_mixer_template_log.InstanceParam))
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(istio_mixer_template_log.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_log.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_log.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetLogTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {

				var BuildTemplate func(instName string, md *istio_mixer_template_log.InstanceParam) (*istio_mixer_template_log.Instance, error)
				_ = BuildTemplate

				var BuildRes1 func(instName string, md *istio_mixer_template_log.Res1InstanceParam) (*istio_mixer_template_log.Res1, error)
				_ = BuildRes1

				var BuildRes2 func(instName string, md *istio_mixer_template_log.Res2InstanceParam) (*istio_mixer_template_log.Res2, error)
				_ = BuildRes2

				BuildTemplate = func(instName string, md *istio_mixer_template_log.InstanceParam) (*istio_mixer_template_log.Instance, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					AnotherValueType, err := mapper.Eval(md.AnotherValueType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DimensionsFixedInt64ValueDType, err := template.EvalAll(md.DimensionsFixedInt64ValueDType, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					TimeStamp, err := mapper.Eval(md.TimeStamp, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval TimeStamp for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Duration, err := mapper.Eval(md.Duration, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Duration for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res1, err := BuildRes1(instName, md.Res1)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res1 for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					return &istio_mixer_template_log.Instance{

						Name: instName,

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						AnotherValueType: AnotherValueType,

						DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(DimensionsFixedInt64ValueDType),

						TimeStamp: TimeStamp.(time.Time),

						Duration: Duration.(time.Duration),

						Res1: Res1,
					}, nil
				}

				BuildRes1 = func(instName string, md *istio_mixer_template_log.Res1InstanceParam) (*istio_mixer_template_log.Res1, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Map, err := template.EvalAll(md.Int64Map, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Map for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					TimeStamp, err := mapper.Eval(md.TimeStamp, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval TimeStamp for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Duration, err := mapper.Eval(md.Duration, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Duration for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res2, err := BuildRes2(instName, md.Res2)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res2 for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Res2Map = make(map[string]*Res2, len(md.Res2Map))
					for k, v := range md.Res2Map {
						if Res2Map[k], err = BuildRes2(v); err != nil {
							return nil, err
						}
					}

					if err != nil {
						msg := fmt.Sprintf("failed to eval Res2Map for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					return &istio_mixer_template_log.Res1{

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						Int64Map: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(Int64Map),

						TimeStamp: TimeStamp.(time.Time),

						Duration: Duration.(time.Duration),

						Res2: Res2,

						Res2Map: Res2Map,
					}, nil
				}

				BuildRes2 = func(instName string, md *istio_mixer_template_log.Res2InstanceParam) (*istio_mixer_template_log.Res2, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					return &istio_mixer_template_log.Res2{

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),
					}, nil
				}

				var instances []*istio_mixer_template_log.Instance
				for instName, inst := range insts {
					instance, err := BuildTemplate(instName, inst.(*istio_mixer_template_log.InstanceParam))
					if err != nil {
						return err
					}
					instances = append(instances, instance)
				}

				if err := handler.(istio_mixer_template_log.Handler).HandleLog(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},

		istio_mixer_template_metric.TemplateName: {
			Name:               istio_mixer_template_metric.TemplateName,
			Impl:               "istio.mixer.template.metric",
			CtrCfg:             &istio_mixer_template_metric.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  istio_mixer_template_metric.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: istio_mixer_template_metric.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_metric.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_metric.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {

				var BuildTemplate func(cpb *istio_mixer_template_metric.InstanceParam) (*istio_mixer_template_metric.Type, error)
				_ = BuildTemplate

				BuildTemplate = func(cpb *istio_mixer_template_metric.InstanceParam) (*istio_mixer_template_metric.Type, error) {
					infrdType := &istio_mixer_template_metric.Type{}
					var err error = nil

					if cpb.Value == "" || cpb.Value == emptyQuotes {
						return nil, errors.New("expression for field Value cannot be empty")
					}
					if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
						return nil, err
					}

					infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
					for k, v := range cpb.Dimensions {

						if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
							return nil, err
						}

					}

					if cpb.Int64Primitive == "" || cpb.Int64Primitive == emptyQuotes {
						return nil, errors.New("expression for field Int64Primitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}

					if cpb.BoolPrimitive == "" || cpb.BoolPrimitive == emptyQuotes {
						return nil, errors.New("expression for field BoolPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
					}

					if cpb.DoublePrimitive == "" || cpb.DoublePrimitive == emptyQuotes {
						return nil, errors.New("expression for field DoublePrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
					}

					if cpb.StringPrimitive == "" || cpb.StringPrimitive == emptyQuotes {
						return nil, errors.New("expression for field StringPrimitive cannot be empty")
					}
					if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
					}

					if cpb.AnotherValueType == "" || cpb.AnotherValueType == emptyQuotes {
						return nil, errors.New("expression for field AnotherValueType cannot be empty")
					}
					if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
						return nil, err
					}

					for _, v := range cpb.DimensionsFixedInt64ValueDType {
						if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
							if e != nil {
								return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
							}
							return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
						}
					}

					return infrdType, err
				}

				return BuildTemplate(cp.(*istio_mixer_template_metric.InstanceParam))
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(istio_mixer_template_metric.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_metric.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_metric.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetMetricTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {

				var BuildTemplate func(instName string, md *istio_mixer_template_metric.InstanceParam) (*istio_mixer_template_metric.Instance, error)
				_ = BuildTemplate

				BuildTemplate = func(instName string, md *istio_mixer_template_metric.InstanceParam) (*istio_mixer_template_metric.Instance, error) {
					if md == nil {
						return nil, nil
					}
					var err error
					_ = err

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					Int64Primitive, err := mapper.Eval(md.Int64Primitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					BoolPrimitive, err := mapper.Eval(md.BoolPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DoublePrimitive, err := mapper.Eval(md.DoublePrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					StringPrimitive, err := mapper.Eval(md.StringPrimitive, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					AnotherValueType, err := mapper.Eval(md.AnotherValueType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					DimensionsFixedInt64ValueDType, err := template.EvalAll(md.DimensionsFixedInt64ValueDType, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
						glog.Error(msg)
						return nil, errors.New(msg)
					}

					return &istio_mixer_template_metric.Instance{

						Name: instName,

						Value: Value,

						Dimensions: Dimensions,

						Int64Primitive: Int64Primitive.(int64),

						BoolPrimitive: BoolPrimitive.(bool),

						DoublePrimitive: DoublePrimitive.(float64),

						StringPrimitive: StringPrimitive.(string),

						AnotherValueType: AnotherValueType,

						DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
							res := make(map[string]int64, len(m))
							for k, v := range m {
								res[k] = v.(int64)
							}
							return res
						}(DimensionsFixedInt64ValueDType),
					}, nil
				}

				var instances []*istio_mixer_template_metric.Instance
				for instName, inst := range insts {
					instance, err := BuildTemplate(instName, inst.(*istio_mixer_template_metric.InstanceParam))
					if err != nil {
						return err
					}
					instances = append(instances, instance)
				}

				if err := handler.(istio_mixer_template_metric.Handler).HandleMetric(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},
	}
)
